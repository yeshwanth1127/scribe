{
  "version": 3,
  "sources": ["../../@tauri-apps/plugin-sql/dist-js/index.js"],
  "sourcesContent": ["import { invoke } from '@tauri-apps/api/core';\r\n\r\n// Copyright 2019-2023 Tauri Programme within The Commons Conservancy\r\n// SPDX-License-Identifier: Apache-2.0\r\n// SPDX-License-Identifier: MIT\r\n/**\r\n * **Database**\r\n *\r\n * The `Database` class serves as the primary interface for\r\n * communicating with the rust side of the sql plugin.\r\n */\r\nclass Database {\r\n    constructor(path) {\r\n        this.path = path;\r\n    }\r\n    /**\r\n     * **load**\r\n     *\r\n     * A static initializer which connects to the underlying database and\r\n     * returns a `Database` instance once a connection to the database is established.\r\n     *\r\n     * # Sqlite\r\n     *\r\n     * The path is relative to `tauri::path::BaseDirectory::App` and must start with `sqlite:`.\r\n     *\r\n     * @example\r\n     * ```ts\r\n     * const db = await Database.load(\"sqlite:test.db\");\r\n     * ```\r\n     */\r\n    static async load(path) {\r\n        const _path = await invoke('plugin:sql|load', {\r\n            db: path\r\n        });\r\n        return new Database(_path);\r\n    }\r\n    /**\r\n     * **get**\r\n     *\r\n     * A static initializer which synchronously returns an instance of\r\n     * the Database class while deferring the actual database connection\r\n     * until the first invocation or selection on the database.\r\n     *\r\n     * # Sqlite\r\n     *\r\n     * The path is relative to `tauri::path::BaseDirectory::App` and must start with `sqlite:`.\r\n     *\r\n     * @example\r\n     * ```ts\r\n     * const db = Database.get(\"sqlite:test.db\");\r\n     * ```\r\n     */\r\n    static get(path) {\r\n        return new Database(path);\r\n    }\r\n    /**\r\n     * **execute**\r\n     *\r\n     * Passes a SQL expression to the database for execution.\r\n     *\r\n     * @example\r\n     * ```ts\r\n     * // for sqlite & postgres\r\n     * // INSERT example\r\n     * const result = await db.execute(\r\n     *    \"INSERT into todos (id, title, status) VALUES ($1, $2, $3)\",\r\n     *    [ todos.id, todos.title, todos.status ]\r\n     * );\r\n     * // UPDATE example\r\n     * const result = await db.execute(\r\n     *    \"UPDATE todos SET title = $1, completed = $2 WHERE id = $3\",\r\n     *    [ todos.title, todos.status, todos.id ]\r\n     * );\r\n     *\r\n     * // for mysql\r\n     * // INSERT example\r\n     * const result = await db.execute(\r\n     *    \"INSERT into todos (id, title, status) VALUES (?, ?, ?)\",\r\n     *    [ todos.id, todos.title, todos.status ]\r\n     * );\r\n     * // UPDATE example\r\n     * const result = await db.execute(\r\n     *    \"UPDATE todos SET title = ?, completed = ? WHERE id = ?\",\r\n     *    [ todos.title, todos.status, todos.id ]\r\n     * );\r\n     * ```\r\n     */\r\n    async execute(query, bindValues) {\r\n        const [rowsAffected, lastInsertId] = await invoke('plugin:sql|execute', {\r\n            db: this.path,\r\n            query,\r\n            values: bindValues ?? []\r\n        });\r\n        return {\r\n            lastInsertId,\r\n            rowsAffected\r\n        };\r\n    }\r\n    /**\r\n     * **select**\r\n     *\r\n     * Passes in a SELECT query to the database for execution.\r\n     *\r\n     * @example\r\n     * ```ts\r\n     * // for sqlite & postgres\r\n     * const result = await db.select(\r\n     *    \"SELECT * from todos WHERE id = $1\", [ id ]\r\n     * );\r\n     *\r\n     * // for mysql\r\n     * const result = await db.select(\r\n     *    \"SELECT * from todos WHERE id = ?\", [ id ]\r\n     * );\r\n     * ```\r\n     */\r\n    async select(query, bindValues) {\r\n        const result = await invoke('plugin:sql|select', {\r\n            db: this.path,\r\n            query,\r\n            values: bindValues ?? []\r\n        });\r\n        return result;\r\n    }\r\n    /**\r\n     * **close**\r\n     *\r\n     * Closes the database connection pool.\r\n     *\r\n     * @example\r\n     * ```ts\r\n     * const success = await db.close()\r\n     * ```\r\n     * @param db - Optionally state the name of a database if you are managing more than one. Otherwise, all database pools will be in scope.\r\n     */\r\n    async close(db) {\r\n        const success = await invoke('plugin:sql|close', {\r\n            db\r\n        });\r\n        return success;\r\n    }\r\n}\r\n\r\nexport { Database as default };\r\n"],
  "mappings": ";;;;;;AAWA,IAAM,WAAN,MAAM,UAAS;AAAA,EACX,YAAY,MAAM;AACd,SAAK,OAAO;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgBA,aAAa,KAAK,MAAM;AACpB,UAAM,QAAQ,MAAM,OAAO,mBAAmB;AAAA,MAC1C,IAAI;AAAA,IACR,CAAC;AACD,WAAO,IAAI,UAAS,KAAK;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiBA,OAAO,IAAI,MAAM;AACb,WAAO,IAAI,UAAS,IAAI;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiCA,MAAM,QAAQ,OAAO,YAAY;AAC7B,UAAM,CAAC,cAAc,YAAY,IAAI,MAAM,OAAO,sBAAsB;AAAA,MACpE,IAAI,KAAK;AAAA,MACT;AAAA,MACA,QAAQ,cAAc,CAAC;AAAA,IAC3B,CAAC;AACD,WAAO;AAAA,MACH;AAAA,MACA;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAmBA,MAAM,OAAO,OAAO,YAAY;AAC5B,UAAM,SAAS,MAAM,OAAO,qBAAqB;AAAA,MAC7C,IAAI,KAAK;AAAA,MACT;AAAA,MACA,QAAQ,cAAc,CAAC;AAAA,IAC3B,CAAC;AACD,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,MAAM,MAAM,IAAI;AACZ,UAAM,UAAU,MAAM,OAAO,oBAAoB;AAAA,MAC7C;AAAA,IACJ,CAAC;AACD,WAAO;AAAA,EACX;AACJ;",
  "names": []
}
