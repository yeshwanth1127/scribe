{
  "version": 3,
  "sources": ["../../hast-util-from-dom/lib/index.js", "../../hast-util-from-html-isomorphic/lib/browser.js", "../../unist-util-find-after/lib/index.js", "../../hast-util-is-element/lib/index.js", "../../hast-util-to-text/lib/index.js", "../../rehype-katex/lib/index.js"],
  "sourcesContent": ["/**\r\n * @import {\r\n *   Comment as HastComment,\r\n *   Doctype as HastDoctype,\r\n *   Element as HastElement,\r\n *   Nodes as HastNodes,\r\n *   RootContent as HastRootContent,\r\n *   Root as HastRoot,\r\n *   Text as HastText,\r\n * } from 'hast'\r\n */\r\n\r\n/**\r\n * @callback AfterTransform\r\n *   Callback called when each node is transformed.\r\n * @param {Node} domNode\r\n *   DOM node that was handled.\r\n * @param {HastNodes} hastNode\r\n *   Corresponding hast node.\r\n * @returns {undefined | void}\r\n *   Nothing.\r\n *\r\n *   Note: `void` included until TS infers `undefined` nicely.\r\n *\r\n * @typedef Options\r\n *   Configuration.\r\n * @property {AfterTransform | null | undefined} [afterTransform]\r\n *   Callback called when each node is transformed (optional).\r\n */\r\n\r\nimport {h, s} from 'hastscript'\r\nimport {webNamespaces} from 'web-namespaces'\r\n\r\n/**\r\n * Transform a DOM tree to a hast tree.\r\n *\r\n * @param {Node} tree\r\n *   DOM tree to transform.\r\n * @param {Options | null | undefined} [options]\r\n *   Configuration (optional).\r\n * @returns {HastNodes}\r\n *   Equivalent hast node.\r\n */\r\nexport function fromDom(tree, options) {\r\n  return transform(tree, options || {}) || {type: 'root', children: []}\r\n}\r\n\r\n/**\r\n * @param {Node} node\r\n *   DOM node to transform.\r\n * @param {Options} options\r\n *   Configuration.\r\n * @returns {HastNodes | undefined}\r\n *   Equivalent hast node.\r\n *\r\n *   Note that certain legacy DOM nodes (i.e., Attr nodes (2),  CDATA, processing instructions)\r\n */\r\nfunction transform(node, options) {\r\n  const transformed = one(node, options)\r\n  if (transformed && options.afterTransform)\r\n    options.afterTransform(node, transformed)\r\n  return transformed\r\n}\r\n\r\n/**\r\n * @param {Node} node\r\n *   DOM node to transform.\r\n * @param {Options} options\r\n *   Configuration.\r\n * @returns {HastNodes | undefined}\r\n *   Equivalent hast node.\r\n */\r\nfunction one(node, options) {\r\n  switch (node.nodeType) {\r\n    case 1 /* Element */: {\r\n      const domNode = /** @type {Element} */ (node)\r\n      return element(domNode, options)\r\n    }\r\n\r\n    // Ignore: Attr (2).\r\n\r\n    case 3 /* Text */: {\r\n      const domNode = /** @type {Text} */ (node)\r\n      return text(domNode)\r\n    }\r\n\r\n    // Ignore: CDATA (4).\r\n    // Removed: Entity reference (5)\r\n    // Removed: Entity (6)\r\n    // Ignore: Processing instruction (7).\r\n\r\n    case 8 /* Comment */: {\r\n      const domNode = /** @type {Comment} */ (node)\r\n      return comment(domNode)\r\n    }\r\n\r\n    case 9 /* Document */: {\r\n      const domNode = /** @type {Document} */ (node)\r\n      return root(domNode, options)\r\n    }\r\n\r\n    case 10 /* Document type */: {\r\n      return doctype()\r\n    }\r\n\r\n    case 11 /* Document fragment */: {\r\n      const domNode = /** @type {DocumentFragment} */ (node)\r\n      return root(domNode, options)\r\n    }\r\n\r\n    default: {\r\n      return undefined\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Transform a document.\r\n *\r\n * @param {Document | DocumentFragment} node\r\n *   DOM node to transform.\r\n * @param {Options} options\r\n *   Configuration.\r\n * @returns {HastRoot}\r\n *   Equivalent hast node.\r\n */\r\nfunction root(node, options) {\r\n  return {type: 'root', children: all(node, options)}\r\n}\r\n\r\n/**\r\n * Transform a doctype.\r\n *\r\n * @returns {HastDoctype}\r\n *   Equivalent hast node.\r\n */\r\nfunction doctype() {\r\n  return {type: 'doctype'}\r\n}\r\n\r\n/**\r\n * Transform a text.\r\n *\r\n * @param {Text} node\r\n *   DOM node to transform.\r\n * @returns {HastText}\r\n *   Equivalent hast node.\r\n */\r\nfunction text(node) {\r\n  return {type: 'text', value: node.nodeValue || ''}\r\n}\r\n\r\n/**\r\n * Transform a comment.\r\n *\r\n * @param {Comment} node\r\n *   DOM node to transform.\r\n * @returns {HastComment}\r\n *   Equivalent hast node.\r\n */\r\nfunction comment(node) {\r\n  return {type: 'comment', value: node.nodeValue || ''}\r\n}\r\n\r\n/**\r\n * Transform an element.\r\n *\r\n * @param {Element} node\r\n *   DOM node to transform.\r\n * @param {Options} options\r\n *   Configuration.\r\n * @returns {HastElement}\r\n *   Equivalent hast node.\r\n */\r\nfunction element(node, options) {\r\n  const space = node.namespaceURI\r\n  const x = space === webNamespaces.svg ? s : h\r\n  const tagName =\r\n    space === webNamespaces.html ? node.tagName.toLowerCase() : node.tagName\r\n  /** @type {DocumentFragment | Element} */\r\n  const content =\r\n    // @ts-expect-error: DOM types are wrong, content can exist.\r\n    space === webNamespaces.html && tagName === 'template' ? node.content : node\r\n  const attributes = node.getAttributeNames()\r\n  /** @type {Record<string, string>} */\r\n  const properties = {}\r\n  let index = -1\r\n\r\n  while (++index < attributes.length) {\r\n    properties[attributes[index]] = node.getAttribute(attributes[index]) || ''\r\n  }\r\n\r\n  return x(tagName, properties, all(content, options))\r\n}\r\n\r\n/**\r\n * Transform child nodes in a parent.\r\n *\r\n * @param {Document | DocumentFragment | Element} node\r\n *   DOM node to transform.\r\n * @param {Options} options\r\n *   Configuration.\r\n * @returns {Array<HastRootContent>}\r\n *   Equivalent hast nodes.\r\n */\r\nfunction all(node, options) {\r\n  const nodes = node.childNodes\r\n  /** @type {Array<HastRootContent>} */\r\n  const children = []\r\n  let index = -1\r\n\r\n  while (++index < nodes.length) {\r\n    const child = transform(nodes[index], options)\r\n\r\n    if (child !== undefined) {\r\n      // @ts-expect-error Assume no document inside document.\r\n      children.push(child)\r\n    }\r\n  }\r\n\r\n  return children\r\n}\r\n", "/**\r\n * @typedef {import('hast').Root} Root\r\n *\r\n * @typedef {typeof import('./index.js').fromHtmlIsomorphic} FromHtmlIsomorphic\r\n */\r\n\r\nimport {fromDom} from 'hast-util-from-dom'\r\n\r\nconst parser = new DOMParser()\r\n\r\n/** @type {FromHtmlIsomorphic} */\r\nexport function fromHtmlIsomorphic(value, options) {\r\n  const node = options?.fragment\r\n    ? parseFragment(value)\r\n    : parser.parseFromString(value, 'text/html')\r\n\r\n  return /** @type {Root} */ (fromDom(node))\r\n}\r\n\r\n/**\r\n * Parse as a fragment.\r\n *\r\n * @param {string} value\r\n * @returns {DocumentFragment}\r\n */\r\nfunction parseFragment(value) {\r\n  const template = document.createElement('template')\r\n  template.innerHTML = value\r\n  return template.content\r\n}\r\n", "/**\r\n * @typedef {import('unist').Node} UnistNode\r\n * @typedef {import('unist').Parent} UnistParent\r\n */\r\n\r\n/**\r\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\r\n *   Test from `unist-util-is`.\r\n *\r\n *   Note: we have remove and add `undefined`, because otherwise when generating\r\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\r\n *   which doesnâ€™t work when publishing on npm.\r\n */\r\n\r\n/**\r\n * @typedef {(\r\n *   Fn extends (value: any) => value is infer Thing\r\n *   ? Thing\r\n *   : Fallback\r\n * )} Predicate\r\n *   Get the value of a type guard `Fn`.\r\n * @template Fn\r\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\r\n * @template Fallback\r\n *   Value to yield if `Fn` is not a type guard.\r\n */\r\n\r\n/**\r\n * @typedef {(\r\n *   Check extends null | undefined // No test.\r\n *   ? Value\r\n *   : Value extends {type: Check} // String (type) test.\r\n *   ? Value\r\n *   : Value extends Check // Partial test.\r\n *   ? Value\r\n *   : Check extends Function // Function test.\r\n *   ? Predicate<Check, Value> extends Value\r\n *     ? Predicate<Check, Value>\r\n *     : never\r\n *   : never // Some other test?\r\n * )} MatchesOne\r\n *   Check whether a node matches a primitive check in the type system.\r\n * @template Value\r\n *   Value; typically unist `Node`.\r\n * @template Check\r\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\r\n */\r\n\r\n/**\r\n * @typedef {(\r\n *   Check extends Array<any>\r\n *   ? MatchesOne<Value, Check[keyof Check]>\r\n *   : MatchesOne<Value, Check>\r\n * )} Matches\r\n *   Check whether a node matches a check in the type system.\r\n * @template Value\r\n *   Value; typically unist `Node`.\r\n * @template Check\r\n *   Value; typically `unist-util-is`-compatible test.\r\n */\r\n\r\n/**\r\n * @typedef {(\r\n *   Kind extends {children: Array<infer Child>}\r\n *   ? Child\r\n *   : never\r\n * )} Child\r\n *   Collect nodes that can be parents of `Child`.\r\n * @template {UnistNode} Kind\r\n *   All node types.\r\n */\r\n\r\nimport {convert} from 'unist-util-is'\r\n\r\n/**\r\n * Find the first node in `parent` after another `node` or after an index,\r\n * that passes `test`.\r\n *\r\n * @param parent\r\n *   Parent node.\r\n * @param index\r\n *   Child node or index.\r\n * @param [test=undefined]\r\n *   Test for child to look for (optional).\r\n * @returns\r\n *   A child (matching `test`, if given) or `undefined`.\r\n */\r\nexport const findAfter =\r\n  // Note: overloads like this are needed to support optional generics.\r\n  /**\r\n   * @type {(\r\n   *   (<Kind extends UnistParent, Check extends Test>(parent: Kind, index: Child<Kind> | number, test: Check) => Matches<Child<Kind>, Check> | undefined) &\r\n   *   (<Kind extends UnistParent>(parent: Kind, index: Child<Kind> | number, test?: null | undefined) => Child<Kind> | undefined)\r\n   * )}\r\n   */\r\n  (\r\n    /**\r\n     * @param {UnistParent} parent\r\n     * @param {UnistNode | number} index\r\n     * @param {Test} [test]\r\n     * @returns {UnistNode | undefined}\r\n     */\r\n    function (parent, index, test) {\r\n      const is = convert(test)\r\n\r\n      if (!parent || !parent.type || !parent.children) {\r\n        throw new Error('Expected parent node')\r\n      }\r\n\r\n      if (typeof index === 'number') {\r\n        if (index < 0 || index === Number.POSITIVE_INFINITY) {\r\n          throw new Error('Expected positive finite number as index')\r\n        }\r\n      } else {\r\n        index = parent.children.indexOf(index)\r\n\r\n        if (index < 0) {\r\n          throw new Error('Expected child node or index')\r\n        }\r\n      }\r\n\r\n      while (++index < parent.children.length) {\r\n        if (is(parent.children[index], index, parent)) {\r\n          return parent.children[index]\r\n        }\r\n      }\r\n\r\n      return undefined\r\n    }\r\n  )\r\n", "/**\r\n * @typedef {import('hast').Element} Element\r\n * @typedef {import('hast').Parents} Parents\r\n */\r\n\r\n/**\r\n * @template Fn\r\n * @template Fallback\r\n * @typedef {Fn extends (value: any) => value is infer Thing ? Thing : Fallback} Predicate\r\n */\r\n\r\n/**\r\n * @callback Check\r\n *   Check that an arbitrary value is an element.\r\n * @param {unknown} this\r\n *   Context object (`this`) to call `test` with\r\n * @param {unknown} [element]\r\n *   Anything (typically a node).\r\n * @param {number | null | undefined} [index]\r\n *   Position of `element` in its parent.\r\n * @param {Parents | null | undefined} [parent]\r\n *   Parent of `element`.\r\n * @returns {boolean}\r\n *   Whether this is an element and passes a test.\r\n *\r\n * @typedef {Array<TestFunction | string> | TestFunction | string | null | undefined} Test\r\n *   Check for an arbitrary element.\r\n *\r\n *   * when `string`, checks that the element has that tag name\r\n *   * when `function`, see `TestFunction`\r\n *   * when `Array`, checks if one of the subtests pass\r\n *\r\n * @callback TestFunction\r\n *   Check if an element passes a test.\r\n * @param {unknown} this\r\n *   The given context.\r\n * @param {Element} element\r\n *   An element.\r\n * @param {number | undefined} [index]\r\n *   Position of `element` in its parent.\r\n * @param {Parents | undefined} [parent]\r\n *   Parent of `element`.\r\n * @returns {boolean | undefined | void}\r\n *   Whether this element passes the test.\r\n *\r\n *   Note: `void` is included until TS sees no return as `undefined`.\r\n */\r\n\r\n/**\r\n * Check if `element` is an `Element` and whether it passes the given test.\r\n *\r\n * @param element\r\n *   Thing to check, typically `element`.\r\n * @param test\r\n *   Check for a specific element.\r\n * @param index\r\n *   Position of `element` in its parent.\r\n * @param parent\r\n *   Parent of `element`.\r\n * @param context\r\n *   Context object (`this`) to call `test` with.\r\n * @returns\r\n *   Whether `element` is an `Element` and passes a test.\r\n * @throws\r\n *   When an incorrect `test`, `index`, or `parent` is given; there is no error\r\n *   thrown when `element` is not a node or not an element.\r\n */\r\nexport const isElement =\r\n  // Note: overloads in JSDoc canâ€™t yet use different `@template`s.\r\n  /**\r\n   * @type {(\r\n   *   (<Condition extends TestFunction>(element: unknown, test: Condition, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &\r\n   *   (<Condition extends string>(element: unknown, test: Condition, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &\r\n   *   ((element?: null | undefined) => false) &\r\n   *   ((element: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &\r\n   *   ((element: unknown, test?: Test, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => boolean)\r\n   * )}\r\n   */\r\n  (\r\n    /**\r\n     * @param {unknown} [element]\r\n     * @param {Test | undefined} [test]\r\n     * @param {number | null | undefined} [index]\r\n     * @param {Parents | null | undefined} [parent]\r\n     * @param {unknown} [context]\r\n     * @returns {boolean}\r\n     */\r\n    // eslint-disable-next-line max-params\r\n    function (element, test, index, parent, context) {\r\n      const check = convertElement(test)\r\n\r\n      if (\r\n        index !== null &&\r\n        index !== undefined &&\r\n        (typeof index !== 'number' ||\r\n          index < 0 ||\r\n          index === Number.POSITIVE_INFINITY)\r\n      ) {\r\n        throw new Error('Expected positive finite `index`')\r\n      }\r\n\r\n      if (\r\n        parent !== null &&\r\n        parent !== undefined &&\r\n        (!parent.type || !parent.children)\r\n      ) {\r\n        throw new Error('Expected valid `parent`')\r\n      }\r\n\r\n      if (\r\n        (index === null || index === undefined) !==\r\n        (parent === null || parent === undefined)\r\n      ) {\r\n        throw new Error('Expected both `index` and `parent`')\r\n      }\r\n\r\n      return looksLikeAnElement(element)\r\n        ? check.call(context, element, index, parent)\r\n        : false\r\n    }\r\n  )\r\n\r\n/**\r\n * Generate a check from a test.\r\n *\r\n * Useful if youâ€™re going to test many nodes, for example when creating a\r\n * utility where something else passes a compatible test.\r\n *\r\n * The created function is a bit faster because it expects valid input only:\r\n * an `element`, `index`, and `parent`.\r\n *\r\n * @param test\r\n *   A test for a specific element.\r\n * @returns\r\n *   A check.\r\n */\r\nexport const convertElement =\r\n  // Note: overloads in JSDoc canâ€™t yet use different `@template`s.\r\n  /**\r\n   * @type {(\r\n   *   (<Condition extends TestFunction>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &\r\n   *   (<Condition extends string>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &\r\n   *   ((test?: null | undefined) => (element?: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &\r\n   *   ((test?: Test) => Check)\r\n   * )}\r\n   */\r\n  (\r\n    /**\r\n     * @param {Test | null | undefined} [test]\r\n     * @returns {Check}\r\n     */\r\n    function (test) {\r\n      if (test === null || test === undefined) {\r\n        return element\r\n      }\r\n\r\n      if (typeof test === 'string') {\r\n        return tagNameFactory(test)\r\n      }\r\n\r\n      // Assume array.\r\n      if (typeof test === 'object') {\r\n        return anyFactory(test)\r\n      }\r\n\r\n      if (typeof test === 'function') {\r\n        return castFactory(test)\r\n      }\r\n\r\n      throw new Error('Expected function, string, or array as `test`')\r\n    }\r\n  )\r\n\r\n/**\r\n * Handle multiple tests.\r\n *\r\n * @param {Array<TestFunction | string>} tests\r\n * @returns {Check}\r\n */\r\nfunction anyFactory(tests) {\r\n  /** @type {Array<Check>} */\r\n  const checks = []\r\n  let index = -1\r\n\r\n  while (++index < tests.length) {\r\n    checks[index] = convertElement(tests[index])\r\n  }\r\n\r\n  return castFactory(any)\r\n\r\n  /**\r\n   * @this {unknown}\r\n   * @type {TestFunction}\r\n   */\r\n  function any(...parameters) {\r\n    let index = -1\r\n\r\n    while (++index < checks.length) {\r\n      if (checks[index].apply(this, parameters)) return true\r\n    }\r\n\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\n * Turn a string into a test for an element with a certain type.\r\n *\r\n * @param {string} check\r\n * @returns {Check}\r\n */\r\nfunction tagNameFactory(check) {\r\n  return castFactory(tagName)\r\n\r\n  /**\r\n   * @param {Element} element\r\n   * @returns {boolean}\r\n   */\r\n  function tagName(element) {\r\n    return element.tagName === check\r\n  }\r\n}\r\n\r\n/**\r\n * Turn a custom test into a test for an element that passes that test.\r\n *\r\n * @param {TestFunction} testFunction\r\n * @returns {Check}\r\n */\r\nfunction castFactory(testFunction) {\r\n  return check\r\n\r\n  /**\r\n   * @this {unknown}\r\n   * @type {Check}\r\n   */\r\n  function check(value, index, parent) {\r\n    return Boolean(\r\n      looksLikeAnElement(value) &&\r\n        testFunction.call(\r\n          this,\r\n          value,\r\n          typeof index === 'number' ? index : undefined,\r\n          parent || undefined\r\n        )\r\n    )\r\n  }\r\n}\r\n\r\n/**\r\n * Make sure something is an element.\r\n *\r\n * @param {unknown} element\r\n * @returns {element is Element}\r\n */\r\nfunction element(element) {\r\n  return Boolean(\r\n    element &&\r\n      typeof element === 'object' &&\r\n      'type' in element &&\r\n      element.type === 'element' &&\r\n      'tagName' in element &&\r\n      typeof element.tagName === 'string'\r\n  )\r\n}\r\n\r\n/**\r\n * @param {unknown} value\r\n * @returns {value is Element}\r\n */\r\nfunction looksLikeAnElement(value) {\r\n  return (\r\n    value !== null &&\r\n    typeof value === 'object' &&\r\n    'type' in value &&\r\n    'tagName' in value\r\n  )\r\n}\r\n", "/**\r\n * @typedef {import('hast').Comment} Comment\r\n * @typedef {import('hast').Element} Element\r\n * @typedef {import('hast').Nodes} Nodes\r\n * @typedef {import('hast').Parents} Parents\r\n * @typedef {import('hast').Text} Text\r\n * @typedef {import('hast-util-is-element').TestFunction} TestFunction\r\n */\r\n\r\n/**\r\n * @typedef {'normal' | 'nowrap' | 'pre' | 'pre-wrap'} Whitespace\r\n *   Valid and useful whitespace values (from CSS).\r\n *\r\n * @typedef {0 | 1 | 2} BreakNumber\r\n *   Specific break:\r\n *\r\n *   *   `0` â€” space\r\n *   *   `1` â€” line ending\r\n *   *   `2` â€” blank line\r\n *\r\n * @typedef {'\\n'} BreakForce\r\n *   Forced break.\r\n *\r\n * @typedef {boolean} BreakValue\r\n *   Whether there was a break.\r\n *\r\n * @typedef {BreakNumber | BreakValue | undefined} BreakBefore\r\n *   Any value for a break before.\r\n *\r\n * @typedef {BreakForce | BreakNumber | BreakValue | undefined} BreakAfter\r\n *   Any value for a break after.\r\n *\r\n * @typedef CollectionInfo\r\n *   Info on current collection.\r\n * @property {BreakAfter} breakAfter\r\n *   Whether there was a break after.\r\n * @property {BreakBefore} breakBefore\r\n *   Whether there was a break before.\r\n * @property {Whitespace} whitespace\r\n *   Current whitespace setting.\r\n *\r\n * @typedef Options\r\n *   Configuration.\r\n * @property {Whitespace | null | undefined} [whitespace='normal']\r\n *   Initial CSS whitespace setting to use (default: `'normal'`).\r\n */\r\n\r\nimport {findAfter} from 'unist-util-find-after'\r\nimport {convertElement} from 'hast-util-is-element'\r\n\r\nconst searchLineFeeds = /\\n/g\r\nconst searchTabOrSpaces = /[\\t ]+/g\r\n\r\nconst br = convertElement('br')\r\nconst cell = convertElement(isCell)\r\nconst p = convertElement('p')\r\nconst row = convertElement('tr')\r\n\r\n// Note that we donâ€™t need to include void elements here as they donâ€™t have text.\r\n// See: <https://github.com/wooorm/html-void-elements>\r\nconst notRendered = convertElement([\r\n  // List from: <https://html.spec.whatwg.org/multipage/rendering.html#hidden-elements>\r\n  'datalist',\r\n  'head',\r\n  'noembed',\r\n  'noframes',\r\n  'noscript', // Act as if we support scripting.\r\n  'rp',\r\n  'script',\r\n  'style',\r\n  'template',\r\n  'title',\r\n  // Hidden attribute.\r\n  hidden,\r\n  // From: <https://html.spec.whatwg.org/multipage/rendering.html#flow-content-3>\r\n  closedDialog\r\n])\r\n\r\n// See: <https://html.spec.whatwg.org/multipage/rendering.html#the-css-user-agent-style-sheet-and-presentational-hints>\r\nconst blockOrCaption = convertElement([\r\n  'address', // Flow content\r\n  'article', // Sections and headings\r\n  'aside', // Sections and headings\r\n  'blockquote', // Flow content\r\n  'body', // Page\r\n  'caption', // `table-caption`\r\n  'center', // Flow content (legacy)\r\n  'dd', // Lists\r\n  'dialog', // Flow content\r\n  'dir', // Lists (legacy)\r\n  'dl', // Lists\r\n  'dt', // Lists\r\n  'div', // Flow content\r\n  'figure', // Flow content\r\n  'figcaption', // Flow content\r\n  'footer', // Flow content\r\n  'form,', // Flow content\r\n  'h1', // Sections and headings\r\n  'h2', // Sections and headings\r\n  'h3', // Sections and headings\r\n  'h4', // Sections and headings\r\n  'h5', // Sections and headings\r\n  'h6', // Sections and headings\r\n  'header', // Flow content\r\n  'hgroup', // Sections and headings\r\n  'hr', // Flow content\r\n  'html', // Page\r\n  'legend', // Flow content\r\n  'li', // Lists (as `display: list-item`)\r\n  'listing', // Flow content (legacy)\r\n  'main', // Flow content\r\n  'menu', // Lists\r\n  'nav', // Sections and headings\r\n  'ol', // Lists\r\n  'p', // Flow content\r\n  'plaintext', // Flow content (legacy)\r\n  'pre', // Flow content\r\n  'section', // Sections and headings\r\n  'ul', // Lists\r\n  'xmp' // Flow content (legacy)\r\n])\r\n\r\n/**\r\n * Get the plain-text value of a node.\r\n *\r\n * ###### Algorithm\r\n *\r\n * *   if `tree` is a comment, returns its `value`\r\n * *   if `tree` is a text, applies normal whitespace collapsing to its\r\n *     `value`, as defined by the CSS Text spec\r\n * *   if `tree` is a root or element, applies an algorithm similar to the\r\n *     `innerText` getter as defined by HTML\r\n *\r\n * ###### Notes\r\n *\r\n * > ðŸ‘‰ **Note**: the algorithm acts as if `tree` is being rendered, and as if\r\n * > weâ€™re a CSS-supporting user agent, with scripting enabled.\r\n *\r\n * *   if `tree` is an element that is not displayed (such as a `head`), weâ€™ll\r\n *     still use the `innerText` algorithm instead of switching to `textContent`\r\n * *   if descendants of `tree` are elements that are not displayed, they are\r\n *     ignored\r\n * *   CSS is not considered, except for the default user agent style sheet\r\n * *   a line feed is collapsed instead of ignored in cases where Fullwidth, Wide,\r\n *     or Halfwidth East Asian Width characters are used, the same goes for a case\r\n *     with Chinese, Japanese, or Yi writing systems\r\n * *   replaced elements (such as `audio`) are treated like non-replaced elements\r\n *\r\n * @param {Nodes} tree\r\n *   Tree to turn into text.\r\n * @param {Readonly<Options> | null | undefined} [options]\r\n *   Configuration (optional).\r\n * @returns {string}\r\n *   Serialized `tree`.\r\n */\r\nexport function toText(tree, options) {\r\n  const options_ = options || {}\r\n  const children = 'children' in tree ? tree.children : []\r\n  const block = blockOrCaption(tree)\r\n  const whitespace = inferWhitespace(tree, {\r\n    whitespace: options_.whitespace || 'normal',\r\n    breakBefore: false,\r\n    breakAfter: false\r\n  })\r\n\r\n  /** @type {Array<BreakNumber | string>} */\r\n  const results = []\r\n\r\n  // Treat `text` and `comment` as having normal white-space.\r\n  // This deviates from the spec as in the DOM the nodeâ€™s `.data` has to be\r\n  // returned.\r\n  // If you want that behavior use `hast-util-to-string`.\r\n  // All other nodes are later handled as if they are `element`s (so the\r\n  // algorithm also works on a `root`).\r\n  // Nodes without children are treated as a void element, so `doctype` is thus\r\n  // ignored.\r\n  if (tree.type === 'text' || tree.type === 'comment') {\r\n    results.push(\r\n      ...collectText(tree, {\r\n        whitespace,\r\n        breakBefore: true,\r\n        breakAfter: true\r\n      })\r\n    )\r\n  }\r\n\r\n  // 1.  If this element is not being rendered, or if the user agent is a\r\n  //     non-CSS user agent, then return the same value as the textContent IDL\r\n  //     attribute on this element.\r\n  //\r\n  //     Note: weâ€™re not supporting stylesheets so weâ€™re acting as if the node\r\n  //     is rendered.\r\n  //\r\n  //     If you want that behavior use `hast-util-to-string`.\r\n  //     Important: weâ€™ll have to account for this later though.\r\n\r\n  // 2.  Let results be a new empty list.\r\n  let index = -1\r\n\r\n  // 3.  For each child node node of this element:\r\n  while (++index < children.length) {\r\n    // 3.1. Let current be the list resulting in running the inner text\r\n    //      collection steps with node.\r\n    //      Each item in results will either be a JavaScript string or a\r\n    //      positive integer (a required line break count).\r\n    // 3.2. For each item item in current, append item to results.\r\n    results.push(\r\n      ...renderedTextCollection(\r\n        children[index],\r\n        // @ts-expect-error: `tree` is a parent if weâ€™re here.\r\n        tree,\r\n        {\r\n          whitespace,\r\n          breakBefore: index ? undefined : block,\r\n          breakAfter:\r\n            index < children.length - 1 ? br(children[index + 1]) : block\r\n        }\r\n      )\r\n    )\r\n  }\r\n\r\n  // 4.  Remove any items from results that are the empty string.\r\n  // 5.  Remove any runs of consecutive required line break count items at the\r\n  //     start or end of results.\r\n  // 6.  Replace each remaining run of consecutive required line break count\r\n  //     items with a string consisting of as many U+000A LINE FEED (LF)\r\n  //     characters as the maximum of the values in the required line break\r\n  //     count items.\r\n  /** @type {Array<string>} */\r\n  const result = []\r\n  /** @type {number | undefined} */\r\n  let count\r\n\r\n  index = -1\r\n\r\n  while (++index < results.length) {\r\n    const value = results[index]\r\n\r\n    if (typeof value === 'number') {\r\n      if (count !== undefined && value > count) count = value\r\n    } else if (value) {\r\n      if (count !== undefined && count > -1) {\r\n        result.push('\\n'.repeat(count) || ' ')\r\n      }\r\n\r\n      count = -1\r\n      result.push(value)\r\n    }\r\n  }\r\n\r\n  // 7.  Return the concatenation of the string items in results.\r\n  return result.join('')\r\n}\r\n\r\n/**\r\n * <https://html.spec.whatwg.org/multipage/dom.html#rendered-text-collection-steps>\r\n *\r\n * @param {Nodes} node\r\n * @param {Parents} parent\r\n * @param {CollectionInfo} info\r\n * @returns {Array<BreakNumber | string>}\r\n */\r\nfunction renderedTextCollection(node, parent, info) {\r\n  if (node.type === 'element') {\r\n    return collectElement(node, parent, info)\r\n  }\r\n\r\n  if (node.type === 'text') {\r\n    return info.whitespace === 'normal'\r\n      ? collectText(node, info)\r\n      : collectPreText(node)\r\n  }\r\n\r\n  return []\r\n}\r\n\r\n/**\r\n * Collect an element.\r\n *\r\n * @param {Element} node\r\n *   Element node.\r\n * @param {Parents} parent\r\n * @param {CollectionInfo} info\r\n *   Info on current collection.\r\n * @returns {Array<BreakNumber | string>}\r\n */\r\nfunction collectElement(node, parent, info) {\r\n  // First we infer the `white-space` property.\r\n  const whitespace = inferWhitespace(node, info)\r\n  const children = node.children || []\r\n  let index = -1\r\n  /** @type {Array<BreakNumber | string>} */\r\n  let items = []\r\n\r\n  // Weâ€™re ignoring point 3, and exiting without any content here, because we\r\n  // deviated from the spec in `toText` at step 3.\r\n  if (notRendered(node)) {\r\n    return items\r\n  }\r\n\r\n  /** @type {BreakNumber | undefined} */\r\n  let prefix\r\n  /** @type {BreakForce | BreakNumber | undefined} */\r\n  let suffix\r\n  // Note: we first detect if there is going to be a break before or after the\r\n  // contents, as that changes the white-space handling.\r\n\r\n  // 2.  If nodeâ€™s computed value of `visibility` is not `visible`, then return\r\n  //     items.\r\n  //\r\n  //     Note: Ignored, as everything is visible by default user agent styles.\r\n\r\n  // 3.  If node is not being rendered, then return items. [...]\r\n  //\r\n  //     Note: We already did this above.\r\n\r\n  // See `collectText` for step 4.\r\n\r\n  // 5.  If node is a `<br>` element, then append a string containing a single\r\n  //     U+000A LINE FEED (LF) character to items.\r\n  if (br(node)) {\r\n    suffix = '\\n'\r\n  }\r\n\r\n  // 7.  If nodeâ€™s computed value of `display` is `table-row`, and nodeâ€™s CSS\r\n  //     box is not the last `table-row` box of the nearest ancestor `table`\r\n  //     box, then append a string containing a single U+000A LINE FEED (LF)\r\n  //     character to items.\r\n  //\r\n  //     See: <https://html.spec.whatwg.org/multipage/rendering.html#tables-2>\r\n  //     Note: needs further investigation as this does not account for implicit\r\n  //     rows.\r\n  else if (\r\n    row(node) &&\r\n    // @ts-expect-error: something up with types of parents.\r\n    findAfter(parent, node, row)\r\n  ) {\r\n    suffix = '\\n'\r\n  }\r\n\r\n  // 8.  If node is a `<p>` element, then append 2 (a required line break count)\r\n  //     at the beginning and end of items.\r\n  else if (p(node)) {\r\n    prefix = 2\r\n    suffix = 2\r\n  }\r\n\r\n  // 9.  If nodeâ€™s used value of `display` is block-level or `table-caption`,\r\n  //     then append 1 (a required line break count) at the beginning and end of\r\n  //     items.\r\n  else if (blockOrCaption(node)) {\r\n    prefix = 1\r\n    suffix = 1\r\n  }\r\n\r\n  // 1.  Let items be the result of running the inner text collection steps with\r\n  //     each child node of node in tree order, and then concatenating the\r\n  //     results to a single list.\r\n  while (++index < children.length) {\r\n    items = items.concat(\r\n      renderedTextCollection(children[index], node, {\r\n        whitespace,\r\n        breakBefore: index ? undefined : prefix,\r\n        breakAfter:\r\n          index < children.length - 1 ? br(children[index + 1]) : suffix\r\n      })\r\n    )\r\n  }\r\n\r\n  // 6.  If nodeâ€™s computed value of `display` is `table-cell`, and nodeâ€™s CSS\r\n  //     box is not the last `table-cell` box of its enclosing `table-row` box,\r\n  //     then append a string containing a single U+0009 CHARACTER TABULATION\r\n  //     (tab) character to items.\r\n  //\r\n  //     See: <https://html.spec.whatwg.org/multipage/rendering.html#tables-2>\r\n  if (\r\n    cell(node) &&\r\n    // @ts-expect-error: something up with types of parents.\r\n    findAfter(parent, node, cell)\r\n  ) {\r\n    items.push('\\t')\r\n  }\r\n\r\n  // Add the pre- and suffix.\r\n  if (prefix) items.unshift(prefix)\r\n  if (suffix) items.push(suffix)\r\n\r\n  return items\r\n}\r\n\r\n/**\r\n * 4.  If node is a Text node, then for each CSS text box produced by node,\r\n *     in content order, compute the text of the box after application of the\r\n *     CSS `white-space` processing rules and `text-transform` rules, set\r\n *     items to the list of the resulting strings, and return items.\r\n *     The CSS `white-space` processing rules are slightly modified:\r\n *     collapsible spaces at the end of lines are always collapsed, but they\r\n *     are only removed if the line is the last line of the block, or it ends\r\n *     with a br element.\r\n *     Soft hyphens should be preserved.\r\n *\r\n *     Note: See `collectText` and `collectPreText`.\r\n *     Note: we donâ€™t deal with `text-transform`, no element has that by\r\n *     default.\r\n *\r\n * See: <https://drafts.csswg.org/css-text/#white-space-phase-1>\r\n *\r\n * @param {Comment | Text} node\r\n *   Text node.\r\n * @param {CollectionInfo} info\r\n *   Info on current collection.\r\n * @returns {Array<BreakNumber | string>}\r\n *   Result.\r\n */\r\nfunction collectText(node, info) {\r\n  const value = String(node.value)\r\n  /** @type {Array<string>} */\r\n  const lines = []\r\n  /** @type {Array<BreakNumber | string>} */\r\n  const result = []\r\n  let start = 0\r\n\r\n  while (start <= value.length) {\r\n    searchLineFeeds.lastIndex = start\r\n\r\n    const match = searchLineFeeds.exec(value)\r\n    const end = match && 'index' in match ? match.index : value.length\r\n\r\n    lines.push(\r\n      // Any sequence of collapsible spaces and tabs immediately preceding or\r\n      // following a segment break is removed.\r\n      trimAndCollapseSpacesAndTabs(\r\n        // [â€¦] ignoring bidi formatting characters (characters with the\r\n        // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if\r\n        // they were not there.\r\n        value\r\n          .slice(start, end)\r\n          .replace(/[\\u061C\\u200E\\u200F\\u202A-\\u202E\\u2066-\\u2069]/g, ''),\r\n        start === 0 ? info.breakBefore : true,\r\n        end === value.length ? info.breakAfter : true\r\n      )\r\n    )\r\n\r\n    start = end + 1\r\n  }\r\n\r\n  // Collapsible segment breaks are transformed for rendering according to the\r\n  // segment break transformation rules.\r\n  // So here we jump to 4.1.2 of [CSSTEXT]:\r\n  // Any collapsible segment break immediately following another collapsible\r\n  // segment break is removed\r\n  let index = -1\r\n  /** @type {BreakNumber | undefined} */\r\n  let join\r\n\r\n  while (++index < lines.length) {\r\n    // *   If the character immediately before or immediately after the segment\r\n    //     break is the zero-width space character (U+200B), then the break is\r\n    //     removed, leaving behind the zero-width space.\r\n    if (\r\n      lines[index].charCodeAt(lines[index].length - 1) === 0x20_0b /* ZWSP */ ||\r\n      (index < lines.length - 1 &&\r\n        lines[index + 1].charCodeAt(0) === 0x20_0b) /* ZWSP */\r\n    ) {\r\n      result.push(lines[index])\r\n      join = undefined\r\n    }\r\n\r\n    // *   Otherwise, if the East Asian Width property [UAX11] of both the\r\n    //     character before and after the segment break is Fullwidth, Wide, or\r\n    //     Halfwidth (not Ambiguous), and neither side is Hangul, then the\r\n    //     segment break is removed.\r\n    //\r\n    //     Note: ignored.\r\n    // *   Otherwise, if the writing system of the segment break is Chinese,\r\n    //     Japanese, or Yi, and the character before or after the segment break\r\n    //     is punctuation or a symbol (Unicode general category P* or S*) and\r\n    //     has an East Asian Width property of Ambiguous, and the character on\r\n    //     the other side of the segment break is Fullwidth, Wide, or Halfwidth,\r\n    //     and not Hangul, then the segment break is removed.\r\n    //\r\n    //     Note: ignored.\r\n\r\n    // *   Otherwise, the segment break is converted to a space (U+0020).\r\n    else if (lines[index]) {\r\n      if (typeof join === 'number') result.push(join)\r\n      result.push(lines[index])\r\n      join = 0\r\n    } else if (index === 0 || index === lines.length - 1) {\r\n      // If this line is empty, and itâ€™s the first or last, add a space.\r\n      // Note that this function is only called in normal whitespace, so we\r\n      // donâ€™t worry about `pre`.\r\n      result.push(0)\r\n    }\r\n  }\r\n\r\n  return result\r\n}\r\n\r\n/**\r\n * Collect a text node as â€œpreâ€ whitespace.\r\n *\r\n * @param {Text} node\r\n *   Text node.\r\n * @returns {Array<BreakNumber | string>}\r\n *   Result.\r\n */\r\nfunction collectPreText(node) {\r\n  return [String(node.value)]\r\n}\r\n\r\n/**\r\n * 3.  Every collapsible tab is converted to a collapsible space (U+0020).\r\n * 4.  Any collapsible space immediately following another collapsible\r\n *     spaceâ€”even one outside the boundary of the inline containing that\r\n *     space, provided both spaces are within the same inline formatting\r\n *     contextâ€”is collapsed to have zero advance width. (It is invisible,\r\n *     but retains its soft wrap opportunity, if any.)\r\n *\r\n * @param {string} value\r\n *   Value to collapse.\r\n * @param {BreakBefore} breakBefore\r\n *   Whether there was a break before.\r\n * @param {BreakAfter} breakAfter\r\n *   Whether there was a break after.\r\n * @returns {string}\r\n *   Result.\r\n */\r\nfunction trimAndCollapseSpacesAndTabs(value, breakBefore, breakAfter) {\r\n  /** @type {Array<string>} */\r\n  const result = []\r\n  let start = 0\r\n  /** @type {number | undefined} */\r\n  let end\r\n\r\n  while (start < value.length) {\r\n    searchTabOrSpaces.lastIndex = start\r\n    const match = searchTabOrSpaces.exec(value)\r\n    end = match ? match.index : value.length\r\n\r\n    // If weâ€™re not directly after a segment break, but there was white space,\r\n    // add an empty value that will be turned into a space.\r\n    if (!start && !end && match && !breakBefore) {\r\n      result.push('')\r\n    }\r\n\r\n    if (start !== end) {\r\n      result.push(value.slice(start, end))\r\n    }\r\n\r\n    start = match ? end + match[0].length : end\r\n  }\r\n\r\n  // If we reached the end, there was trailing white space, and thereâ€™s no\r\n  // segment break after this node, add an empty value that will be turned\r\n  // into a space.\r\n  if (start !== end && !breakAfter) {\r\n    result.push('')\r\n  }\r\n\r\n  return result.join(' ')\r\n}\r\n\r\n/**\r\n * Figure out the whitespace of a node.\r\n *\r\n * We donâ€™t support void elements here (so `nobr wbr` -> `normal` is ignored).\r\n *\r\n * @param {Nodes} node\r\n *   Node (typically `Element`).\r\n * @param {CollectionInfo} info\r\n *   Info on current collection.\r\n * @returns {Whitespace}\r\n *   Applied whitespace.\r\n */\r\nfunction inferWhitespace(node, info) {\r\n  if (node.type === 'element') {\r\n    const properties = node.properties || {}\r\n    switch (node.tagName) {\r\n      case 'listing':\r\n      case 'plaintext':\r\n      case 'xmp': {\r\n        return 'pre'\r\n      }\r\n\r\n      case 'nobr': {\r\n        return 'nowrap'\r\n      }\r\n\r\n      case 'pre': {\r\n        return properties.wrap ? 'pre-wrap' : 'pre'\r\n      }\r\n\r\n      case 'td':\r\n      case 'th': {\r\n        return properties.noWrap ? 'nowrap' : info.whitespace\r\n      }\r\n\r\n      case 'textarea': {\r\n        return 'pre-wrap'\r\n      }\r\n\r\n      default:\r\n    }\r\n  }\r\n\r\n  return info.whitespace\r\n}\r\n\r\n/**\r\n * @type {TestFunction}\r\n * @param {Element} node\r\n * @returns {node is {properties: {hidden: true}}}\r\n */\r\nfunction hidden(node) {\r\n  return Boolean((node.properties || {}).hidden)\r\n}\r\n\r\n/**\r\n * @type {TestFunction}\r\n * @param {Element} node\r\n * @returns {node is {tagName: 'td' | 'th'}}\r\n */\r\nfunction isCell(node) {\r\n  return node.tagName === 'td' || node.tagName === 'th'\r\n}\r\n\r\n/**\r\n * @type {TestFunction}\r\n */\r\nfunction closedDialog(node) {\r\n  return node.tagName === 'dialog' && !(node.properties || {}).open\r\n}\r\n", "/**\r\n * @import {ElementContent, Root} from 'hast'\r\n * @import {KatexOptions} from 'katex'\r\n * @import {VFile} from 'vfile'\r\n */\r\n\r\n/**\r\n * @typedef {Omit<KatexOptions, 'displayMode' | 'throwOnError'>} Options\r\n */\r\n\r\nimport {fromHtmlIsomorphic} from 'hast-util-from-html-isomorphic'\r\nimport {toText} from 'hast-util-to-text'\r\nimport katex from 'katex'\r\nimport {SKIP, visitParents} from 'unist-util-visit-parents'\r\n\r\n/** @type {Readonly<Options>} */\r\nconst emptyOptions = {}\r\n/** @type {ReadonlyArray<unknown>} */\r\nconst emptyClasses = []\r\n\r\n/**\r\n * Render elements with a `language-math` (or `math-display`, `math-inline`)\r\n * class with KaTeX.\r\n *\r\n * @param {Readonly<Options> | null | undefined} [options]\r\n *   Configuration (optional).\r\n * @returns\r\n *   Transform.\r\n */\r\nexport default function rehypeKatex(options) {\r\n  const settings = options || emptyOptions\r\n\r\n  /**\r\n   * Transform.\r\n   *\r\n   * @param {Root} tree\r\n   *   Tree.\r\n   * @param {VFile} file\r\n   *   File.\r\n   * @returns {undefined}\r\n   *   Nothing.\r\n   */\r\n  return function (tree, file) {\r\n    visitParents(tree, 'element', function (element, parents) {\r\n      const classes = Array.isArray(element.properties.className)\r\n        ? element.properties.className\r\n        : emptyClasses\r\n      // This class can be generated from markdown with ` ```math `.\r\n      const languageMath = classes.includes('language-math')\r\n      // This class is used by `remark-math` for flow math (block, `$$\\nmath\\n$$`).\r\n      const mathDisplay = classes.includes('math-display')\r\n      // This class is used by `remark-math` for text math (inline, `$math$`).\r\n      const mathInline = classes.includes('math-inline')\r\n      let displayMode = mathDisplay\r\n\r\n      // Any class is fine.\r\n      if (!languageMath && !mathDisplay && !mathInline) {\r\n        return\r\n      }\r\n\r\n      let parent = parents[parents.length - 1]\r\n      let scope = element\r\n\r\n      // If this was generated with ` ```math `, replace the `<pre>` and use\r\n      // display.\r\n      if (\r\n        element.tagName === 'code' &&\r\n        languageMath &&\r\n        parent &&\r\n        parent.type === 'element' &&\r\n        parent.tagName === 'pre'\r\n      ) {\r\n        scope = parent\r\n        parent = parents[parents.length - 2]\r\n        displayMode = true\r\n      }\r\n\r\n      /* c8 ignore next -- verbose to test. */\r\n      if (!parent) return\r\n\r\n      const value = toText(scope, {whitespace: 'pre'})\r\n\r\n      /** @type {Array<ElementContent> | string | undefined} */\r\n      let result\r\n\r\n      try {\r\n        result = katex.renderToString(value, {\r\n          ...settings,\r\n          displayMode,\r\n          throwOnError: true\r\n        })\r\n      } catch (error) {\r\n        const cause = /** @type {Error} */ (error)\r\n        const ruleId = cause.name.toLowerCase()\r\n\r\n        file.message('Could not render math with KaTeX', {\r\n          ancestors: [...parents, element],\r\n          cause,\r\n          place: element.position,\r\n          ruleId,\r\n          source: 'rehype-katex'\r\n        })\r\n\r\n        // KaTeX *should* handle `ParseError` itself, but not others.\r\n        // it doesnâ€™t always:\r\n        // <https://github.com/remarkjs/react-markdown/issues/853>\r\n        try {\r\n          result = katex.renderToString(value, {\r\n            ...settings,\r\n            displayMode,\r\n            strict: 'ignore',\r\n            throwOnError: false\r\n          })\r\n        } catch {\r\n          // Generate similar markup if this is an other error.\r\n          // See: <https://github.com/KaTeX/KaTeX/blob/5dc7af0/docs/error.md>.\r\n          result = [\r\n            {\r\n              type: 'element',\r\n              tagName: 'span',\r\n              properties: {\r\n                className: ['katex-error'],\r\n                style: 'color:' + (settings.errorColor || '#cc0000'),\r\n                title: String(error)\r\n              },\r\n              children: [{type: 'text', value}]\r\n            }\r\n          ]\r\n        }\r\n      }\r\n\r\n      if (typeof result === 'string') {\r\n        const root = fromHtmlIsomorphic(result, {fragment: true})\r\n        // Cast as we donâ€™t expect `doctypes` in KaTeX result.\r\n        result = /** @type {Array<ElementContent>} */ (root.children)\r\n      }\r\n\r\n      const index = parent.children.indexOf(scope)\r\n      parent.children.splice(index, 1, ...result)\r\n      return SKIP\r\n    })\r\n  }\r\n}\r\n"],
  "mappings": "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",
  "names": ["element", "index", "element", "root"]
}
